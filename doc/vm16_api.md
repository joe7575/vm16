# VM16 Lua API

The VM16 virtual machine provides the following API functions.



## version

```lua
vm16.version
```

Version float number of the vm16 library, like `3.01`.

## create

```lua
vm = vm16.create(pos, ram_size)
```

Initially create the virtual machine VM13. Valid values for `ram_size` are:

- 0 for 512 words of memory
- 1 for 1 KWord of memory
- 2 for 2 KWords of memory
- 3 for 4 KWords of memory
- 4 for 8 KWords of memory
- 5 for 16 KWords of memory
- 6 for 32 KWords of memory
- 7 for 64 KWords of memory

The function returns true/false.

## destroy

```lua
vm16.destroy(pos)
```

Delete the instance and the stored VM data.

## is_loaded

```lua
vm16.is_loaded(pos)
```

Return true if VM is loaded, otherwise false.

## vm_restore

```lua
vm16.vm_restore(pos)
```

Move stored VM back to active. Typically called from the node LBM function. 
(The `vm_store` function is called automatically when the block gets unloaded)

## mem_size

```lua
vm16.mem_size(pos)
```

Returns the VM memory size in words.

## set_pc

```lua
 res = vm16.set_pc(pos, addr)
```

Load the PC (program counter) of the VM with the given 16-bit address.
The function returns true/false.

## get_pc

```lua
 addr = vm16.get_pc(pos)
```

Return the current PC value.

## deposit

```lua
res = vm16.deposit(pos, value)
```

Store the given value in the memory cell where the PC points to and post-increment the PC. The function returns true/false.

## read_mem

```lua
tbl = vm16.read_mem(pos, addr, num)
```

Read a memory block starting at the given `addr` with `num` number of words.
Function returns an table/array with the read values.

## write_mem

```lua
num = vm16.write_mem(pos, addr, tbl)
```

Write a memory block with values from `tbl` starting at the given `addr`. 
Function returns the number of written values.

## read_mem_bin

```lua
tbl = vm16.read_mem(pos, addr, num)
```

Read a memory block starting at the given `addr` with `num` number of words.
Function returns the read values as binary string.

## write_mem_bin

```lua
res = vm16.write_mem(pos, addr, s)
```

Write a memory block provided as binary string, starting at the given `addr` . 
Function returns true if successful.

## read_ascii

```lua
s = vm16.read_ascii(pos, addr, num)
```

Read a memory block starting at the given `addr` and return the
data as ASCII string with up to `num` characters.

## write_ascii

```lua
res = vm16.write_ascii(pos, addr, s)
```

Write ASCII string to given address `addr`. Function returns true if successful.

## is_ascii

```lua
res = vm16.is_ascii(s)
```

The function checks whether the specified string is a real ASCII string (all values between 32 and 127 or '\n') and returns true in this case; otherwise, it returns false.

## peek

```lua
val = vm16.peek(pos, addr)
```

Peek and return the memory cell at `addr`.

## poke

```lua
res = vm16.poke(pos, addr, value)
```

Write a value to the given `addr`.  Function returns true/false.

## get_cpu_reg

```lua
tbl = vm16.get_cpu_reg(pos)
```

Return the complete register set as table with the keys `A`, `B`, `C`, `D`, `X`, `Y`, `PC`, `SP`, plus 2 memory cells `mem0` and `mem1` (the PC points to `mem0`)

## set_cpu_reg

```lua
tbl = vm16.set_cpu_reg(pos, regs)
```

Set the complete register set via the given table with the keys `A`, `B`, `C`, `D`, `X`, `Y`, `PC`, `SP`.

## get_io_reg

```lua
tbl = vm16.get_cpu_reg(pos)
```

Return a reduced register set as table with the keys `A`, `B`, `addr` and `data` , nedded for input/output operations.

## set_io_reg

```lua
tbl = vm16.get_cpu_reg(pos, io)
```

Store the values from the given io table (keys: `A`, `B`, `addr` and `data`)

## write_h16

```lua
res = vm16.write_h16(pos, s)
```

Write a H16 file (generated by the assembler) into VM memory.
Function returns true/false

## read_h16

```lua
res = vm16.read_h16(pos, start_addr, size)
```

Read  memory areas which are not equal to zero and return the data as H16 string. This is used to save program code e. g. to tape. 
`start_addr` and `size` are optional parameters. If no value is given, the complete RAM will be considered.
Function returns true/false.

## testbit

```lua
res = vm16.testbit(value, bit)
```

Test if the `bit` number (0..15) is set in `value`
Function returns true/false

## run

```lua
resp, ran = vm16.run(pos, cycles, callbacks, breakpoints)
```

Call the VM to execute the given number of `cycles`. If `cycles` is nil, the default value 10000 is used.
`callbacks` is a table, generated via `vm16.generate_callback_table()`.
`breakpoints` is a table, maintained by `set_breakpoint` and `reset_breakpoint`.

The response value is one of:

- `vm16.OK` - the VM terminated after the given number of cycles (or slot time expired)
- `VM16_BREAK` - the VM terminated with a `brk` instruction
- `vm16.HALT` - the VM terminated with a `halt` instruction
- `vm16.ERROR` - the VM terminated because of an internal error

## generate_callback_table

```lua
callbacks = vm16.generate_callback_table(on_inp, on_outp, on_sys, on_upd)
```

Funktion to setup the `callbacks` table with the following callback function:

```lua
value = on_input(pos, address)                -- called for each `in <reg>, #<address>`
on_output(pos, address, val1, val2)           -- called for each `out #<address>, <reg>`
result = on_system(pos, address, val1, val2)  -- called for each `sys #<number>`
on_update(pos, resp, regs)                    -- called for each CPU interruption
```

## set_breakpoint

```lua
vm16.set_breakpoint(pos, address, breakpoints)
```

Set a breakpoint on the given `address`. The table `breakpoints` is used to store the breakpoint data for the call of `vm16.run`.

## reset_breakpoint

```lua
vm16.reset_breakpoint(pos, addr, breakpoints)
```

Reset a breakpoint on the given `address`. The table `breakpoints` is used to store the breakpoint data for the call of `vm16.run`.



# API for I/O Nodes

The `io.lua` file provides the following API for I/O nodes.



## register_io_nodes

```lua
vm16.register_io_nodes(names)
```

Register a table of `names` of I/O nodes. When the CPU starts, it looks around for registered nodes to set up the input/output tables.

## register_input_address

```lua
vm16.register_input_address(pos, cpu_pos, address, function(pos, address))
```

Function is used to register an input address and a callback function. This function is then called for each `in <reg>, #<address>` CPU instruction to read the input value.

## register_output_address

```lua
vm16.register_output_address(pos, cpu_pos, address, function(pos, address, value))
```

Function is used to register an output address and a callback function. This function is then called for each `out #<address>, <reg>` CPU instruction to output the provided `value`.



# CPU I/O API

The `io.lua` file provides the following API for the CPU.



## find_io_nodes

```lua
vm16.find_io_nodes(cpu_pos, radius)
```

Funktion is called, when the CPU is created, to collect all I/O nodes and setup the input/output tables.

## on_output

```lua
vm16.on_output(pos, address, val1, val2)
```

Called by the CPU for each `out #<address>, <reg>` instruction.

## on_input

```lua
vm16.on_input(pos, address)
```

Called by the CPU for each `in <reg>, #<address>` instruction.
