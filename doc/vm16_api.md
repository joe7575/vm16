# VM16 Lua API

The VM16 virtual machine provides the following API functions.



## version

```lua
vm16.version
```

Version float number of the vm16 library, like `3.01`.

## create

```lua
vm = vm16.create(pos, ram_size)
```

Initially create the virtual machine VM13. Valid values for `ram_size` are:

- 0 for 64 words of memory
- 1 for 128 words of memory
- 2 for 256 words of memory
- 3 for 512 words of memory
- 4 for 1 KWord of memory
- 5 for 2 KWords of memory
- 6 for 4 KWords of memory
- 7 for 8 KWords of memory
- 8 for 16 KWords of memory
- 9 for 32 KWords of memory
- 10 for 64 KWords of memory

The function returns true/false.

## destroy

```lua
vm16.destroy(pos)
```

Delete the instance and the stored VM data.

## is_loaded

```lua
vm16.is_loaded(pos)
```

Return true if VM is loaded, otherwise false.

## vm_restore

```lua
vm16.vm_restore(pos)
```

Move stored VM back to active. Typically called from the node LBM function. 
(The `vm_store` function is called automatically when the block gets unloaded)

## mem_size

```lua
vm16.mem_size(pos)
```

Returns the VM memory size in words.

## set_pc

```lua
 res = vm16.set_pc(pos, addr)
```

Load the PC (program counter) of the VM with the given 16-bit address.
The function returns true/false.

## get_pc

```lua
 addr = vm16.get_pc(pos)
```

Return the current PC value.

## deposit

```lua
res = vm16.deposit(pos, value)
```

Store the given value in the memory cell where the PC points to and post-increment the PC. The function returns true/false.

## read_mem

```lua
tbl = vm16.read_mem(pos, addr, num)
```

Read a memory block starting at the given `addr` with `num` number of words.
Function returns an table/array with the read values.

## write_mem

```lua
num = vm16.write_mem(pos, addr, tbl)
```

Write a memory block with values from `tbl` starting at the given `addr`. 
Function returns the number of written values.

## read_mem_as_str

```lua
tbl = vm16.read_mem_as_str(pos, addr, num)
```

Read a memory block starting at the given `addr` with `num` number of words.
Function returns the read values as ASCII string for storage purposes.

## write_mem_as_str

```lua
res = vm16.write_mem_as_str(pos, addr, s)
```

Write a memory block provided as ASCII string, starting at the given `addr` . 
Function returns true if successful.

## read_mem_bin

```lua
tbl = vm16.read_mem_bin(pos, addr, num)
```

Read a memory block starting at the given `addr` with `num` number of words.
Function returns the read values as binary string.

## write_mem_bin

```lua
res = vm16.write_mem_bin(pos, addr, s)
```

Write a memory block provided as binary string, starting at the given `addr` . 
Function returns true if successful.

## read_ascii

```lua
s = vm16.read_ascii(pos, addr, num)
```

Read a memory block starting at the given `addr` and return the
data as ASCII string with up to `num` characters.

## write_ascii

```lua
res = vm16.write_ascii(pos, addr, s)
```

Write ASCII string to given address `addr`. Function returns true if successful.

## write_ascii_16

```lua
res = vm16.write_ascii_16(pos, addr, s)
```

Write ASCII string to given address `addr` as 16-bit/compact string. Function returns true if successful.

## is_ascii

```lua
res = vm16.is_ascii(s)
```

The function checks whether the specified string is a real ASCII string (all values between 32 and 127 or '\n') and returns true in this case; otherwise, it returns false.

## peek

```lua
val = vm16.peek(pos, addr)
```

Peek and return the memory cell at `addr`.

## poke

```lua
res = vm16.poke(pos, addr, value)
```

Write a value to the given `addr`.  Function returns true/false.

## get_cpu_reg

```lua
tbl = vm16.get_cpu_reg(pos)
```

Return the complete register set as table with the keys `A`, `B`, `C`, `D`, `X`, `Y`, `PC`, `SP`, plus 2 memory cells `mem0` and `mem1` (the PC points to `mem0`)

## set_cpu_reg

```lua
tbl = vm16.set_cpu_reg(pos, regs)
```

Set the complete register set via the given table with the keys `A`, `B`, `C`, `D`, `X`, `Y`, `PC`, `SP`.

## get_io_reg

```lua
tbl = vm16.get_cpu_reg(pos)
```

Return a reduced register set as table with the keys `A`, `B`, `addr` and `data` , nedded for input/output operations.

## set_io_reg

```lua
tbl = vm16.get_cpu_reg(pos, io)
```

Store the values from the given io table (keys: `A`, `B`, `addr` and `data`)

## write_h16

```lua
res = vm16.write_h16(pos, s)
```

Write a H16 file (generated by the assembler) into VM memory.
Function returns true/false

## read_h16

```lua
res = vm16.read_h16(pos, start_addr, size)
```

Read  memory areas which are not equal to zero and return the data as H16 string. This is used to save program code e. g. to tape. 
`start_addr` and `size` are optional parameters. If no value is given, the complete RAM will be considered.
Function returns true/false.

## testbit

```lua
res = vm16.testbit(value, bit)
```

Test if the `bit` number (0..15) is set in `value`
Function returns true/false

## run

```lua
resp, ran = vm16.run(pos, cpu_def, breakpoints)
```

Call the VM to execute the loaded program.
`cpu_def` is a table with CPU specific parameters and functions.
`breakpoints` is a table, maintained by `set_breakpoint` and `reset_breakpoint`.

The response value is one of:

- `vm16.OK` - the VM terminated after the given number of cycles (or slot time expired)
- `VM16_BREAK` - the VM terminated with a `brk` instruction
- `vm16.HALT` - the VM terminated with a `halt` instruction
- `vm16.ERROR` - the VM terminated because of an internal error

## set_breakpoint

```lua
vm16.set_breakpoint(pos, address, breakpoints)
```

Set a breakpoint on the given `address`. The table `breakpoints` is used to store the breakpoint data for the call of `vm16.run`.

## reset_breakpoint

```lua
vm16.reset_breakpoint(pos, addr, breakpoints)
```

Reset a breakpoint on the given `address`. The table `breakpoints` is used to store the breakpoint data for the call of `vm16.run`.

## Table `cpu_def`

```lua
local cpu_def = {
	cycle_time = 0.1, -- timer cycle time
	instr_per_cycle = 10000,
	input_costs = 1000,  -- number of instructions for an input call
	output_costs = 5000, -- number of instructions for an output call
	system_costs = 2000, -- number of instructions for a system call
	-- Called for each 'input' instruction. Function returns the input value.
	on_input = function(pos, address) ... end,
	-- Called for each 'output' instruction.
	on_output = function(pos, address, val1, val2) ... end,
	-- Called for each 'system' instruction.
	on_system = function(pos, address, val1, val2) ... end,
	-- Called when CPU stops (halt, breakpoint, ...)
	on_update = function(pos, resp) ... end,
    
    -- The following functions are only needed by the programmer (see demo implementation)
	on_init = function(pos, prog_pos) ... end,
	on_mem_size = function(pos) ... end,
	on_start = function(pos) ... end,
	on_stop = function(pos) ... end,
	on_check_connection = function(pos) ... end,
	on_infotext = function(pos) ... end,
}
```

