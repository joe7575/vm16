vm16 version = 2.7.4

 #### Compile 'main': test01.c ####
;##### test01.c #####
newfile test01.c
  .code
  global var1
  global var2
  global var3
  global get_five
  global foo
  global test_basic
  global test_4_param
  global test_expr
  global test_expr2
  global main
  call main
  halt
@init:
;   1: var var1;
;   2: var var2 = 2;
  move var2, #2
;   3: var var3 = var2 * 2;
  move A, var2
  mul A, #2
  move var3, A
  ret
;   5: func get_five() {
get_five:
;   6:   return 5;
  move A, #5
  ret
;   7: }
;   9: func foo(a,b) {
foo:
;  10:   var c = a;
  push [SP+2]
;  11:   var d = b;
  push [SP+2]
;  12:   return c * d;
  move A, [SP+1]
  mul A, [SP+0]
  move A, A
  add SP, #2
  ret
;  13: }
;  15: func test_basic(a) {
test_basic:
;  16:   var d = 4;
  push #4
;  17:   if(d > a) {
  move A, [SP+0]
  skgt A, [SP+2]
  jump @lbl2
@lbl1:
;  18:     return 0;
  move A, #0
  add SP, #1
  ret
;  19:   }
@lbl2:
;  20:   return 15;
  move A, #15
  add SP, #1
  ret
;  21: }
;  23: func test_4_param(a, b, c, d) {
test_4_param:
;  24:   return a + b + c + d;
  move A, [SP+2]
  add A, [SP+1]
  move B, [SP+3]
  add B, A
  move C, [SP+4]
  add C, B
  move A, C
  ret
;  25: }
;  27: func test_expr(a, b, c, d) {
test_expr:
;  28:   return a * get_five() + (b - 2) * c / d;
  call get_five
  move B, [SP+4]
  mul B, A
  move C, [SP+3]
  sub C, #2
  move D, [SP+2]
  div D, [SP+1]
  mul C, D
  add B, C
  move A, B
  ret
;  29: }
;  31: func test_expr2(a, b, c, d) {
test_expr2:
;  32:   return test_basic(a + b) + (b - 2) * c / d;
  move A, [SP+4]
  add A, [SP+3]
  push A
  call test_basic
  add SP, #1
  move B, [SP+3]
  sub B, #2
  move C, [SP+2]
  div C, [SP+1]
  mul B, C
  add A, B
  move A, A
  ret
;  33: }
;  35: func main() {
main:
;  36:   var c = var1 + 1;
  move A, var1
  add A, #1
  push A
;  37:   var res;
  push #0
;  39:   output(15, test_basic(14));
  push #14
  call test_basic
  add SP, #1
  out #15, A
;  40:   output(1, c);
  out #1, [SP+1]
;  41:   c = (c + 3) * 2;
  move A, [SP+1]
  add A, #3
  mul A, #2
  move [SP+1], A
;  42:   output(8, c);
  out #8, [SP+1]
;  43:   system(2, var1, 0);
  move A, var1
  move B, #0
  sys #2
;  44:   system(2, var1 + 3, 0);
  move A, var1
  add A, #3
  move B, #0
  sys #2
;  45:   var2 = input(3);
  in A, #3
  move var2, A
;  46:   output(12, var2);
  out #12, var2
;  47:   sleep(5);
  move A, #5
  nop
  dbnz A, -1
;  48:   output(5, get_five());
  call get_five
  out #5, A
;  50:   output(15, test_basic(14));
  push #14
  call test_basic
  add SP, #1
  out #15, A
;  51:   c = 8;
  move [SP+1], #8
;  52:   var2 = 12;
  move var2, #12
;  53:   res = test_4_param(c, c, c, var2);
  push [SP+1]
  push [SP+2]
  push [SP+3]
  push var2
  call test_4_param
  add SP, #4
  move [SP+0], A
;  54:   output(36, res);
  out #36, [SP+0]
;  55:   res = test_4_param(1, c, c, var2);
  push #1
  push [SP+2]
  push [SP+3]
  push var2
  call test_4_param
  add SP, #4
  move [SP+0], A
;  56:   output(29, res);
  out #29, [SP+0]
;  57:   //                 1 + 5        + 8 + 12
;  58:   c = test_4_param(1, get_five(), c, var2);
  push #1
  call get_five
  push A
  push [SP+3]
  push var2
  call test_4_param
  add SP, #4
  move [SP+1], A
;  59:   output(26, c);
  out #26, [SP+1]
;  61:   // 2 * 5 + (4 - 2) * 4 / 4 = 10 + 8 / 4 = 10 + 2 = 12
;  62:   res = test_expr(2, 4, 4, 4);
  push #2
  push #4
  push #4
  push #4
  call test_expr
  add SP, #4
  move [SP+0], A
;  63:   output(12, res);
  out #12, [SP+0]
;  65:   // d < (2 + 4) => 15: 15 + (4 - 2) * 4 / 4 = 15 + 2 = 17
;  66:   res = test_expr2(2, 4, 4, 4);
  push #2
  push #4
  push #4
  push #4
  call test_expr2
  add SP, #4
  move [SP+0], A
;  67:   output(17, res);
  out #17, [SP+0]
  add SP, #2
  ret
;  68: }
  .data
var1: 0
var2: 0
var3: 0
#### Code ####
 file   0 0000: test01.c
 code   0 0000: 1600 005C
 code   0 0002: 1C00
 code   2 0003: 2230 00F4 0002
 code   3 0006: 2011 00F4
 code   3 0008: 3810 0002
 code   3 000A: 2220 00F5
 code   0 000C: 1800
 code   6 000D: 2010 0005
 code   6 000F: 1800
 code  10 0010: 6A60 0002
 code  11 0012: 6A60 0002
 code  12 0014: 2013 0001
 code  12 0016: 3813 0000
 code  12 0018: 2000
 code  12 0019: 30F0 0002
 code  12 001B: 1800
 code  16 001C: 6A00 0004
 code  17 001E: 2013 0000
 code  17 0020: 9813 0002
 code  17 0022: 1200 0027
 code  18 0024: 200C
 code  18 0025: 30ED
 code  18 0026: 1800
 code  20 0027: 2010 000F
 code  20 0029: 30ED
 code  20 002A: 1800
 code  24 002B: 2013 0002
 code  24 002D: 3013 0001
 code  24 002F: 2033 0003
 code  24 0031: 3020
 code  24 0032: 2053 0004
 code  24 0034: 3041
 code  24 0035: 2002
 code  24 0036: 1800
 code  28 0037: 1600 000D
 code  28 0039: 2033 0004
 code  28 003B: 3820
 code  28 003C: 2053 0003
 code  28 003E: 3450 0002
 code  28 0040: 2073 0002
 code  28 0042: 3C73 0001
 code  28 0044: 3843
 code  28 0045: 3022
 code  28 0046: 2001
 code  28 0047: 1800
 code  32 0048: 2013 0004
 code  32 004A: 3013 0003
 code  32 004C: 6800
 code  32 004D: 1600 001C
 code  32 004F: 30ED
 code  32 0050: 2033 0003
 code  32 0052: 3430 0002
 code  32 0054: 2053 0002
 code  32 0056: 3C53 0001
 code  32 0058: 3822
 code  32 0059: 3001
 code  32 005A: 2000
 code  32 005B: 1800
 code  36 005C: 2011 00F3
 code  36 005E: 300D
 code  36 005F: 6800
 code  37 0060: 6980
 code  39 0061: 6A00 000E
 code  39 0063: 1600 001C
 code  39 0065: 30ED
 code  39 0066: 6600 000F
 code  40 0068: 65B3 0001
 code  41 006A: 2013 0001
 code  41 006C: 3010 0003
 code  41 006E: 3810 0002
 code  41 0070: 2260 0001
 code  42 0072: 6613 0008 0001
 code  43 0075: 2011 00F3
 code  43 0077: 202C
 code  43 0078: 0802
 code  44 0079: 2011 00F3
 code  44 007B: 3010 0003
 code  44 007D: 202C
 code  44 007E: 0802
 code  45 007F: 6010 0003
 code  45 0081: 2220 00F4
 code  46 0083: 6611 000C 00F4
 code  47 0086: 2010 0005
 code  47 0088: 0000
 code  47 0089: 7414 FFFF
 code  48 008B: 1600 000D
 code  48 008D: 6600 0005
 code  50 008F: 6A00 000E
 code  50 0091: 1600 001C
 code  50 0093: 30ED
 code  50 0094: 6600 000F
 code  51 0096: 2270 0001 0008
 code  52 0099: 2230 00F4 000C
 code  53 009C: 6A60 0001
 code  53 009E: 6A60 0002
 code  53 00A0: 6A60 0003
 code  53 00A2: 6A20 00F4
 code  53 00A4: 1600 002B
 code  53 00A6: 30F0 0004
 code  53 00A8: 2260 0000
 code  54 00AA: 6613 0024 0000
 code  55 00AD: 69A0
 code  55 00AE: 6A60 0002
 code  55 00B0: 6A60 0003
 code  55 00B2: 6A20 00F4
 code  55 00B4: 1600 002B
 code  55 00B6: 30F0 0004
 code  55 00B8: 2260 0000
 code  56 00BA: 6613 001D 0000
 code  58 00BD: 69A0
 code  58 00BE: 1600 000D
 code  58 00C0: 6800
 code  58 00C1: 6A60 0003
 code  58 00C3: 6A20 00F4
 code  58 00C5: 1600 002B
 code  58 00C7: 30F0 0004
 code  58 00C9: 2260 0001
 code  59 00CB: 6613 001A 0001
 code  62 00CE: 6A00 0002
 code  62 00D0: 6A00 0004
 code  62 00D2: 6A00 0004
 code  62 00D4: 6A00 0004
 code  62 00D6: 1600 0037
 code  62 00D8: 30F0 0004
 code  62 00DA: 2260 0000
 code  63 00DC: 6613 000C 0000
 code  66 00DF: 6A00 0002
 code  66 00E1: 6A00 0004
 code  66 00E3: 6A00 0004
 code  66 00E5: 6A00 0004
 code  66 00E7: 1600 0048
 code  66 00E9: 30F0 0004
 code  66 00EB: 2260 0000
 code  67 00ED: 6613 0011 0000
 code  67 00F0: 30F0 0002
 code  67 00F2: 1800
 code   1 00F3: 0000
 code   2 00F4: 0000
 code   3 00F5: 0000
#### Debug ####
 file   0 0000: "test01.c"
 gvar   1 00F3: "var1"
 gvar   2 00F4: "var2"
 gvar   3 00F5: "var3"
 func   5 000D: "get_five"
  ret   6 0000: "0"
 svar   6    0: "@num_stack_var@"
 func   9 0010: "foo"
  ret  12 0000: "0"
 svar  12    2: "a"
 svar  12   -1: "c"
 svar  12    1: "b"
 svar  12   -2: "d"
 svar  12    2: "@num_stack_var@"
 func  15 001C: "test_basic"
brnch  17 0027: "@lbl2"
  ret  18 0000: "0"
  ret  20 0000: "0"
 svar  20    1: "a"
 svar  20   -1: "d"
 svar  20    1: "@num_stack_var@"
 func  23 002B: "test_4_param"
  ret  24 0000: "0"
 svar  24    4: "a"
 svar  24    2: "c"
 svar  24    3: "b"
 svar  24    1: "d"
 svar  24    0: "@num_stack_var@"
 func  27 0037: "test_expr"
  ret  28 0000: "0"
 call  28 000D: "get_five"
 svar  28    4: "a"
 svar  28    2: "c"
 svar  28    3: "b"
 svar  28    1: "d"
 svar  28    0: "@num_stack_var@"
 func  31 0048: "test_expr2"
  ret  32 0000: "0"
 call  32 001C: "test_basic"
 svar  32    4: "a"
 svar  32    2: "c"
 svar  32    3: "b"
 svar  32    1: "d"
 svar  32    0: "@num_stack_var@"
 func  35 005C: "main"
 call  39 001C: "test_basic"
 call  48 000D: "get_five"
 call  50 001C: "test_basic"
 call  53 002B: "test_4_param"
 call  55 002B: "test_4_param"
 call  58 000D: "get_five"
 call  58 002B: "test_4_param"
 call  62 0037: "test_expr"
 call  66 0048: "test_expr2"
 svar  67   -2: "res"
 svar  67   -1: "c"
 svar  67    2: "@num_stack_var@"
 endf  70 00F6: "test01.c"

 #### Compile 'main': test02.c ####
;##### test02.c #####
newfile test02.c
  .code
  global a
  global b
  global c
  global d
  global foo
  global main
  call main
  halt
@init:
;   1: var a = 2;
  move a, #2
;   2: var b = 3;
  move b, #3
;   3: var c = 4;
  move c, #4
;   4: var d = 5;
  move d, #5
  ret
;   6: func foo(a) {
foo:
;   7:   return a;
  move A, [SP+1]
  ret
;   8: }
;  10: func main() {
main:
;  11:   d = (a * b) + (c * d);
  move A, a
  mul A, b
  move B, c
  mul B, d
  add A, B
  move d, A
;  12:   d = foo(a * b) + (c * d);
  move A, a
  mul A, b
  push A
  call foo
  add SP, #1
  move B, c
  mul B, d
  add A, B
  move d, A
;  13:   d = (a * b) + foo(c * d);
  move A, a
  mul A, b
  push A
  move A, c
  mul A, d
  push A
  call foo
  add SP, #1
  move B, A
  pop  A
  add A, B
  move d, A
;  14:   d = 3 + (a * b) + foo(c * d);
  move A, a
  mul A, b
  push A
  move A, c
  mul A, d
  push A
  call foo
  add SP, #1
  move B, A
  pop  A
  add A, B
  move C, #3
  add C, A
  move d, C
;  15:   d = 4 + foo(a * b) + (c * d);
  move A, a
  mul A, b
  push A
  call foo
  add SP, #1
  move B, c
  mul B, d
  add A, B
  move C, #4
  add C, A
  move d, C
  ret
;  16: }
  .data
a: 0
b: 0
c: 0
d: 0
#### Code ####
 file   0 0000: test02.c
 code   0 0000: 1600 000F
 code   0 0002: 1C00
 code   1 0003: 2010 0002
 code   2 0005: 2030 0003
 code   3 0007: 2050 0004
 code   4 0009: 2070 0005
 code   0 000B: 1800
 code   7 000C: 2013 0001
 code   7 000E: 1800
 code  11 000F: 2000
 code  11 0010: 3801
 code  11 0011: 2022
 code  11 0012: 3823
 code  11 0013: 3001
 code  11 0014: 2060
 code  12 0015: 2000
 code  12 0016: 3801
 code  12 0017: 6800
 code  12 0018: 1600 000C
 code  12 001A: 30ED
 code  12 001B: 2022
 code  12 001C: 3823
 code  12 001D: 3001
 code  12 001E: 2060
 code  13 001F: 2000
 code  13 0020: 3801
 code  13 0021: 6800
 code  13 0022: 2002
 code  13 0023: 3803
 code  13 0024: 6800
 code  13 0025: 1600 000C
 code  13 0027: 30ED
 code  13 0028: 2020
 code  13 0029: 6C00
 code  13 002A: 3001
 code  13 002B: 2060
 code  14 002C: 2000
 code  14 002D: 3801
 code  14 002E: 6800
 code  14 002F: 2002
 code  14 0030: 3803
 code  14 0031: 6800
 code  14 0032: 1600 000C
 code  14 0034: 30ED
 code  14 0035: 2020
 code  14 0036: 6C00
 code  14 0037: 3001
 code  14 0038: 2050 0003
 code  14 003A: 3040
 code  14 003B: 2062
 code  15 003C: 2000
 code  15 003D: 3801
 code  15 003E: 6800
 code  15 003F: 1600 000C
 code  15 0041: 30ED
 code  15 0042: 2022
 code  15 0043: 3823
 code  15 0044: 3001
 code  15 0045: 2050 0004
 code  15 0047: 3040
 code  15 0048: 2062
 code  15 0049: 1800
 code   1 004A: 0000
 code   2 004B: 0000
 code   3 004C: 0000
 code   4 004D: 0000
#### Debug ####
 file   0 0000: "test02.c"
 gvar   1 004A: "a"
 gvar   2 004B: "b"
 gvar   3 004C: "c"
 gvar   4 004D: "d"
 func   6 000C: "foo"
  ret   7 0000: "0"
 svar   7    1: "a"
 svar   7    0: "@num_stack_var@"
 func  10 000F: "main"
 call  12 000C: "foo"
 call  13 000C: "foo"
 call  14 000C: "foo"
 call  15 000C: "foo"
 svar  15    0: "@num_stack_var@"
 endf  18 004E: "test02.c"

 #### Compile 'main': test03.c ####
;##### test03.c #####
newfile test03.c
  .code
  global var1
  global Drehzahl
  global get_char
  global foo
  global main
  call main
  halt
@init:
;   1: var var1 = 0;
  move var1, #0
  ret
;   2: var Drehzahl;
;   4: func get_char(c) {
get_char:
;   5:   var1 = c;
  move var1, [SP+1]
;   6:   if(c > 20) {
  move A, [SP+1]
  skgt A, #20
  jump @lbl2
@lbl1:
;   7:     return 1;
  move A, #1
  ret
;   8:   } else {
  jump @lbl3
@lbl2:
;   9:     return 65 + c;
  move A, #65
  add A, [SP+1]
  move A, A
  ret
@lbl3:
;  10:   }
;  11:   var1 = var1 + 1;
  move A, var1
  add A, #1
  move var1, A
  ret
;  12: }
;  14: func foo() {
foo:
;  15:   var a = -1;
  move A, #1
  not A
  add A, #1
  push A
;  16:   var b = 2;
  push #2
;  18:   if(a == ~0xffff){
  move A, #65535
  not A
  move B, [SP+1]
  skeq B, A
  jump @lbl5
@lbl4:
;  19:     output(0, 0x41);
  out #0, #65
;  20:   } else {
  jump @lbl6
@lbl5:
;  21:     output(0, 0x42);
  out #0, #66
@lbl6:
;  22:   }
  add SP, #2
  ret
;  23: }
;  25: func main() {
main:
;  26:   var i = 1;
  push #1
;  27:   var c;
  push #0
;  29:   sleep(5);
  move A, #5
  nop
  dbnz A, -1
;  30:   foo();
  call foo
;  31:   while(i < 32) {
@lbl7:
  move A, [SP+1]
  sklt A, #32
  jump @lbl8
;  32:     c = get_char(i);
  push [SP+1]
  call get_char
  add SP, #1
  move [SP+0], A
;  33:     output(0, c);
  out #0, [SP+0]
;  34:     i = i + 1;
  move A, [SP+1]
  add A, #1
  move [SP+1], A
  jump @lbl7
@lbl8:
;  35:   }
  add SP, #2
  ret
;  36: }
  .data
var1: 0
Drehzahl: 0
#### Code ####
 file   0 0000: test03.c
 code   0 0000: 1600 0036
 code   0 0002: 1C00
 code   1 0003: 222C 0058
 code   0 0005: 1800
 code   5 0006: 2233 0058 0001
 code   6 0009: 2013 0001
 code   6 000B: 9810 0014
 code   6 000D: 1200 0013
 code   7 000F: 200D
 code   7 0010: 1800
 code   8 0011: 1200 0019
 code   9 0013: 2010 0041
 code   9 0015: 3013 0001
 code   9 0017: 2000
 code   9 0018: 1800
 code  11 0019: 2011 0058
 code  11 001B: 300D
 code  11 001C: 2220 0058
 code  11 001E: 1800
 code  15 001F: 200D
 code  15 0020: 4C00
 code  15 0021: 300D
 code  15 0022: 6800
 code  16 0023: 6A00 0002
 code  18 0025: 2010 FFFF
 code  18 0027: 4C00
 code  18 0028: 2033 0001
 code  18 002A: 9020
 code  18 002B: 1200 0031
 code  19 002D: 6590 0041
 code  20 002F: 1200 0033
 code  21 0031: 6590 0042
 code  22 0033: 30F0 0002
 code  22 0035: 1800
 code  26 0036: 69A0
 code  27 0037: 6980
 code  29 0038: 2010 0005
 code  29 003A: 0000
 code  29 003B: 7414 FFFF
 code  30 003D: 1600 001F
 code  31 003F: 2013 0001
 code  31 0041: 9410 0020
 code  31 0043: 1200 0055
 code  32 0045: 6A60 0001
 code  32 0047: 1600 0006
 code  32 0049: 30ED
 code  32 004A: 2260 0000
 code  33 004C: 6593 0000
 code  34 004E: 2013 0001
 code  34 0050: 300D
 code  34 0051: 2260 0001
 code  34 0053: 1200 003F
 code  35 0055: 30F0 0002
 code  35 0057: 1800
 code   1 0058: 0000
 code   2 0059: 0000
#### Debug ####
 file   0 0000: "test03.c"
 gvar   1 0058: "var1"
 gvar   2 0059: "Drehzahl"
 func   4 0006: "get_char"
brnch   6 0013: "@lbl2"
  ret   7 0000: "0"
brnch   8 0019: "@lbl3"
  ret   9 0000: "0"
 svar  11    1: "c"
 svar  11    0: "@num_stack_var@"
 func  14 001F: "foo"
brnch  18 0031: "@lbl5"
brnch  20 0033: "@lbl6"
 svar  22   -1: "a"
 svar  22   -2: "b"
 svar  22    2: "@num_stack_var@"
 func  25 0036: "main"
 call  30 001F: "foo"
brnch  31 0055: "@lbl8"
 call  32 0006: "get_char"
brnch  34 003F: "@lbl7"
 svar  35   -1: "i"
 svar  35   -2: "c"
 svar  35    2: "@num_stack_var@"
 endf  38 005A: "test03.c"

 #### Compile 'main': test04.c ####
;##### test04.c #####
newfile test04.c
  .code
  global main
  call main
  halt
@init:
  ret
;   1: const MAX = 32;
;   3: func main() {
main:
;   4:   var i = 1;
  push #1
;   5:   var ptr = 0x100;
  push #256
;   7:   output(1, i);
  out #1, [SP+1]
;   8:   while(i < MAX) {
@lbl1:
  move A, [SP+1]
  sklt A, #32
  jump @lbl2
;   9:     i = i + 1;
  move A, [SP+1]
  add A, #1
  move [SP+1], A
;  10:     i = *ptr;
  move X, [SP+0]
  move [SP+1], [X]
;  12:     _asm_ {
;  13:       move A, #3
  move A, #3
;  14:       xor $100, [X]++
  xor $100, [X]++
;  15:       jump 0
  jump 0
  jump @lbl1
@lbl2:
;  16:     }
;  17:   }
  add SP, #2
  ret
;  18: }
#### Code ####
 file   0 0000: test04.c
 code   0 0000: 1600 0004
 code   0 0002: 1C00
 code   0 0003: 1800
 code   4 0004: 69A0
 code   5 0005: 6A00 0100
 code   7 0007: 65B3 0001
 code   8 0009: 2013 0001
 code   8 000B: 9410 0020
 code   8 000D: 1200 0020
 code   9 000F: 2013 0001
 code   9 0011: 300D
 code   9 0012: 2260 0001
 code  10 0014: 2093 0000
 code  10 0016: 2268 0001
 code  13 0018: 2010 0003
 code  14 001A: 4A20 0100
 code  15 001C: 1200 0000
 code  15 001E: 1200 0009
 code  17 0020: 30F0 0002
 code  17 0022: 1800
#### Debug ####
 file   0 0000: "test04.c"
 func   3 0004: "main"
brnch   8 0020: "@lbl2"
brnch  15 0009: "@lbl1"
 svar  17   -1: "i"
 svar  17   -2: "ptr"
 svar  17    2: "@num_stack_var@"
 endf  19 0023: "test04.c"

 #### Compile 'main': test05.c ####
;##### test05.c #####
newfile test05.c
  .code
  global arr1
  global arr2
  global out
  global str
  global memcpy
  global putval
  global putstr
  global main
  call main
  halt
@init:
;   1: var arr1[4];
;   2: var arr2[4] = {1, 2, 3, 4};
;   3: var out[6];
;   4: var str = "Hello Joe!";
  move str, #@s1
  ret
;   6: func memcpy(dst, src, num) {
memcpy:
;   7:   while(num > 0) {
@lbl1:
  move A, [SP+1]
  skgt A, #0
  jump @lbl2
;   8:     *dst = *src;
  move X, [SP+2]
  move Y, [SP+3]
  move [Y], [X]
;   9:     dst++;
  inc [SP+3]
;  10:     src++;
  inc [SP+2]
;  11:     num--;
  dec [SP+1]
  jump @lbl1
@lbl2:
;  12:   }
  ret
;  13: }
;  15: func putval(val) {
putval:
;  16:   var c;
  push #0
;  17:   var r = val;
  push [SP+2]
;  18:   var i = 0;
  push #0
;  20:   if(val == 0) {
  move A, [SP+4]
  skeq A, #0
  jump @lbl4
@lbl3:
;  21:     output(0, 0x30);
  out #0, #48
;  22:     return;
  move A, #0
  add SP, #3
  ret
;  23:   }
@lbl4:
;  25:   while(r > 0) {
@lbl5:
  move A, [SP+1]
  skgt A, #0
  jump @lbl6
;  26:     c = r % 10;
  move A, [SP+1]
  mod A, #10
  move [SP+2], A
;  27:     r = r / 10;
  move A, [SP+1]
  div A, #10
  move [SP+1], A
;  28:     out[i] = c + 0x30;
  move A, [SP+2]
  add A, #48
  move B, #out
  add B, [SP+0]
  move X, B
  move [X], A
;  29:     i++;
  inc [SP+0]
  jump @lbl5
@lbl6:
;  30:   }
;  31:   for(; i > 0; i--) {
@lbl7:
  move A, [SP+0]
  skgt A, #0
  jump @lbl8
;  32:     output(0, out[i-1]);
  move A, [SP+0]
  sub A, #1
  move B, #out
  add B, A
  move X, B
  out #0, [X]
@lbl9:
  dec [SP+0]
  jump @lbl7
@lbl8:
;  33:   }
  add SP, #3
  ret
;  34: }
;  36: func putstr(s) {
putstr:
;  37:   var i;
  push #0
;  39:   while(s[i] != 0) {
@lbl10:
  move A, [SP+2]
  add A, [SP+0]
  move X, A
  move B, [X]
  skne B, #0
  jump @lbl11
;  40:     output(0, s[i]);
  move A, [SP+2]
  add A, [SP+0]
  move X, A
  out #0, [X]
;  41:     i++;
  inc [SP+0]
  jump @lbl10
@lbl11:
;  42:   }
  add SP, #1
  ret
;  43: }
;  45: func main() {
main:
;  46:   var i;
  push #0
;  47:   var c = i + 1;
  move A, [SP+0]
  add A, #1
  push A
;  48:   var p1 = arr1;
  push #arr1
;  49:   var p2 = str;
  push str
;  51:   memcpy(arr1, arr2, 4);
  push #arr1
  push #arr2
  push #4
  call memcpy
  add SP, #3
;  53:   for(i = 0; i < 4; i++) {
  move [SP+3], #0
@lbl12:
  move A, [SP+3]
  sklt A, #4
  jump @lbl13
;  54:     putval(arr1[i]);
  move A, #arr1
  add A, [SP+3]
  move X, A
  push [X]
  call putval
  add SP, #1
@lbl14:
  inc [SP+3]
  jump @lbl12
@lbl13:
;  55:   }
;  56:   output(0, '  ');
  out #0, #8224
;  57:   putval(0x55AA);
  push #21930
  call putval
  add SP, #1
;  58:   output(0, '  ');
  out #0, #8224
;  59:   putstr(str);
  push str
  call putstr
  add SP, #1
;  60:   output(0, '  ');
  out #0, #8224
;  61:   putstr(p2);
  push [SP+0]
  call putstr
  add SP, #1
;  62:   putstr("Hello world!");
  push #@s2
  call putstr
  add SP, #1
  add SP, #4
  ret
;  63: }
  .data
arr1: 0,0,0,0
arr2: 1,2,3,4
out: 0,0,0,0,0,0
str: 0
  .ctext
  @s1: "Hello Joe!\0"
  @s2: "Hello world!\0"
#### Code ####
 file   0 0000: test05.c
 code   0 0000: 1600 0072
 code   0 0002: 1C00
 code   4 0003: 2230 00C5 00C6
 code   0 0006: 1800
 code   7 0007: 2013 0001
 code   7 0009: 980C
 code   7 000A: 1200 0019
 code   8 000C: 2093 0002
 code   8 000E: 20B3 0003
 code   8 0010: 2128
 code   9 0011: 2A60 0003
 code  10 0013: 2A60 0002
 code  11 0015: 2E60 0001
 code  11 0017: 1200 0007
 code  12 0019: 1800
 code  16 001A: 6980
 code  17 001B: 6A60 0002
 code  18 001D: 6980
 code  20 001E: 2013 0004
 code  20 0020: 900C
 code  20 0021: 1200 0029
 code  21 0023: 6590 0030
 code  22 0025: 200C
 code  22 0026: 30F0 0003
 code  22 0028: 1800
 code  25 0029: 2013 0001
 code  25 002B: 980C
 code  25 002C: 1200 0048
 code  26 002E: 2013 0001
 code  26 0030: 7810 000A
 code  26 0032: 2260 0002
 code  27 0034: 2013 0001
 code  27 0036: 3C10 000A
 code  27 0038: 2260 0001
 code  28 003A: 2013 0002
 code  28 003C: 3010 0030
 code  28 003E: 2030 00BF
 code  28 0040: 3033 0000
 code  28 0042: 2081
 code  28 0043: 2100
 code  29 0044: 2A60 0000
 code  29 0046: 1200 0029
 code  31 0048: 2013 0000
 code  31 004A: 980C
 code  31 004B: 1200 0059
 code  32 004D: 2013 0000
 code  32 004F: 340D
 code  32 0050: 2030 00BF
 code  32 0052: 3020
 code  32 0053: 2081
 code  32 0054: 6588
 code  31 0055: 2E60 0000
 code  32 0057: 1200 0048
 code  33 0059: 30F0 0003
 code  33 005B: 1800
 code  37 005C: 6980
 code  39 005D: 2013 0002
 code  39 005F: 3013 0000
 code  39 0061: 2080
 code  39 0062: 2028
 code  39 0063: 8C2C
 code  39 0064: 1200 0070
 code  40 0066: 2013 0002
 code  40 0068: 3013 0000
 code  40 006A: 2080
 code  40 006B: 6588
 code  41 006C: 2A60 0000
 code  41 006E: 1200 005D
 code  42 0070: 30ED
 code  42 0071: 1800
 code  46 0072: 6980
 code  47 0073: 2013 0000
 code  47 0075: 300D
 code  47 0076: 6800
 code  48 0077: 6A00 00B7
 code  49 0079: 6A20 00C5
 code  51 007B: 6A00 00B7
 code  51 007D: 6A00 00BB
 code  51 007F: 6A00 0004
 code  51 0081: 1600 0007
 code  51 0083: 30F0 0003
 code  53 0085: 226C 0003
 code  53 0087: 2013 0003
 code  53 0089: 9410 0004
 code  53 008B: 1200 009A
 code  54 008D: 2010 00B7
 code  54 008F: 3013 0003
 code  54 0091: 2080
 code  54 0092: 6900
 code  54 0093: 1600 001A
 code  54 0095: 30ED
 code  53 0096: 2A60 0003
 code  54 0098: 1200 0087
 code  56 009A: 6590 2020
 code  57 009C: 6A00 55AA
 code  57 009E: 1600 001A
 code  57 00A0: 30ED
 code  58 00A1: 6590 2020
 code  59 00A3: 6A20 00C5
 code  59 00A5: 1600 005C
 code  59 00A7: 30ED
 code  60 00A8: 6590 2020
 code  61 00AA: 6A60 0000
 code  61 00AC: 1600 005C
 code  61 00AE: 30ED
 code  62 00AF: 6A00 00CC
 code  62 00B1: 1600 005C
 code  62 00B3: 30ED
 code  62 00B4: 30F0 0004
 code  62 00B6: 1800
 code   1 00B7: 0000 0000 0000 0000
 code   2 00BB: 0001 0002 0003 0004
 code   3 00BF: 0000 0000 0000 0000 0000 0000
 code   4 00C5: 0000
 code   4 00C6: 4865 6C6C 6F20 4A6F 6521 0000
 code  62 00CC: 4865 6C6C 6F20 776F 726C 6421 0000
#### Debug ####
 file   0 0000: "test05.c"
 gvar   1 00B7: "arr1[]"
 gvar   2 00BB: "arr2[]"
 gvar   3 00BF: "out[]"
 gvar   4 00C5: "str"
 func   6 0007: "memcpy"
brnch   7 0019: "@lbl2"
brnch  11 0007: "@lbl1"
 svar  12    3: "dst"
 svar  12    2: "src"
 svar  12    1: "num"
 svar  12    0: "@num_stack_var@"
 func  15 001A: "putval"
brnch  20 0029: "@lbl4"
  ret  22 0000: "0"
brnch  25 0048: "@lbl6"
brnch  29 0029: "@lbl5"
brnch  31 0059: "@lbl8"
brnch  32 0048: "@lbl7"
 svar  33   -3: "i"
 svar  33   -1: "c"
 svar  33   -2: "r"
 svar  33    1: "val"
 svar  33    3: "@num_stack_var@"
 func  36 005C: "putstr"
brnch  39 0070: "@lbl11"
brnch  41 005D: "@lbl10"
 svar  42   -1: "i"
 svar  42    1: "s"
 svar  42    1: "@num_stack_var@"
 func  45 0072: "main"
 call  51 0007: "memcpy"
brnch  53 009A: "@lbl13"
 call  54 001A: "putval"
brnch  54 0087: "@lbl12"
 call  57 001A: "putval"
 call  59 005C: "putstr"
 call  61 005C: "putstr"
 call  62 005C: "putstr"
 svar  62   -1: "i"
 svar  62   -2: "c"
 svar  62   -4: "p2"
 svar  62   -3: "p1"
 svar  62    4: "@num_stack_var@"
 endf  64 00D3: "test05.c"

 #### Compile 'main': test06.c ####
;##### test06.c #####
newfile test06.c
  .code
  global arr@6
  global main
  call main
  halt
@init:
  ret
;##### string.asm #####
newfile string.asm
;   1: ;===================================
;   2: ; [20] string v1.0
;   3: ; - strcpy(dst, src)
;   4: ; - strlen(s)
;   5: ;===================================
;   7: global strcpy
  .code
  global strcpy
;   8: global strlen
  global strlen
;  10:   .code
;  12: ;===================================
;  13: ; [01] strcpy(dst, src)
;  14: ; dst: [SP+2]
;  15: ; src: [SP+1]
;  16: ;===================================
;  17: strcpy:
strcpy:
;  18:   move X, [SP+2]
  move X, [SP+2]
;  19:   move Y, [SP+1]
  move Y, [SP+1]
;  20:   move A, X
  move A, X
;  22: loop01:
loop01:
;  23:   move [X]+, [Y]
  move [X]+, [Y]
;  24:   bnze [Y]+, loop01
  bnze [Y]+, loop01
;  26:   ret
  ret
;  28: ;===================================
;  29: ; [02] strlen(str)
;  30: ; str: [SP+1]
;  31: ;===================================
;  32: strlen:
strlen:
;  33:   move X, [SP+1]
  move X, [SP+1]
;  34:   move A, #0
  move A, #0
;  36: loop02:
loop02:
;  37:   move B, [X]+
  move B, [X]+
;  38:   inc  A
  inc  A
;  39:   bnze [X], loop02
  bnze [X], loop02
;  41:   ret
  ret
;##### stdio.asm #####
newfile stdio.asm
;   1: ;===================================
;   2: ; Standard I/O v1.0
;   3: ; - putchar(c)
;   4: ; - putstr(s)
;   5: ; - putnum(val)  -- decimal output
;   6: ; - puthex(val)  -- hexadecimal output
;   7: ;===================================
;   9: global putchar
  .code
  global putchar
;  10: global putstr
  global putstr
;  11: global putnum
  global putnum
;  12: global puthex
  global puthex
;  14:   .code
;  16: ;===================================
;  17: ; [01] putchar(c)
;  18: ; c: [SP+1]
;  19: ;===================================
;  20: putchar:
putchar:
;  21:   move A, [SP+1]
  move A, [SP+1]
;  22:   out  #0, A
  out  #0, A
;  23:   ret
  ret
;  25: ;===================================
;  26: ; [02] putstr(s)
;  27: ; s: [SP+1]
;  28: ;===================================
;  29: putstr:
putstr:
;  30:   move X, [SP+1]
  move X, [SP+1]
;  31:   move A, #80  ; max string size
  move A, #80  ; max string size
;  33: loop02:
loop02:
;  34:   move B, [X]
  move B, [X]
;  35:   bze  B, exit02
  bze  B, exit02
;  36:   dec  A
  dec  A
;  37:   bze  A, exit02
  bze  A, exit02
;  39:   out #0, B
  out #0, B
;  40:   inc X
  inc X
;  41:   jump loop02
  jump loop02
;  43: exit02:
exit02:
;  44:   ret
  ret
;  46: ;===================================
;  47: ; [03] putnum(val)
;  48: ; val: [SP+1]
;  49: ;===================================
;  50: putnum:
putnum:
;  51:   move A, [SP+1]
  move A, [SP+1]
;  52:   push #0        ; end-of-string
  push #0        ; end-of-string
;  54: loop03:
loop03:
;  55:   move B, A
  move B, A
;  56:   div  B, #10    ; rest in B
  div  B, #10    ; rest in B
;  57:   move C, A
  move C, A
;  58:   mod  C, #10    ; digit in C
  mod  C, #10    ; digit in C
;  59:   add  C, #48
  add  C, #48
;  60:   push C         ; store on stack
  push C         ; store on stack
;  61:   move A, B
  move A, B
;  62:   bnze A, loop03 ; next digit
  bnze A, loop03 ; next digit
;  64: output03:
output03:
;  65:   pop  B
  pop  B
;  66:   bze  B, exit03
  bze  B, exit03
;  67:   out  #0, B
  out  #0, B
;  68:   jump output03
  jump output03
;  70: exit03:
exit03:
;  71:   ret
  ret
;  73: ;===================================
;  74: ; [04] puthex(val)
;  75: ; val: [SP+1]
;  76: ;===================================
;  77: puthex:
puthex:
;  78:   move A, [SP+1]
  move A, [SP+1]
;  79:   push #0        ; end-of-string
  push #0        ; end-of-string
;  80:   move C, #4     ; num digits
  move C, #4     ; num digits
;  82: loop04:
loop04:
;  83:   move B, A
  move B, A
;  84:   div  B, #$10   ; rest in B
  div  B, #$10   ; rest in B
;  85:   mod  A, #$10   ; digit in C
  mod  A, #$10   ; digit in C
;  86:   sklt A, #10    ; C < 10 => jmp +2
  sklt A, #10    ; C < 10 => jmp +2
;  87:   add  A, #7     ; A-F offset
  add  A, #7     ; A-F offset
;  88:   add  A, #48    ; 0-9 offset
  add  A, #48    ; 0-9 offset
;  89:   push A         ; store on stack
  push A         ; store on stack
;  90:   move A, B
  move A, B
;  91:   dbnz C, loop04 ; next digit
  dbnz C, loop04 ; next digit
;  93: output04:
output04:
;  94:   pop  B
  pop  B
;  95:   bze  B, exit04
  bze  B, exit04
;  96:   out  #0, B
  out  #0, B
;  97:   jump output04
  jump output04
;  99: exit04:
exit04:
; 100:   ret
  ret
;##### test06.c #####
newfile test06.c
;   1: import "string.asm"
;   2: import "stdio.asm"
;   4: static var arr[10];
;   6: func main() {
  .code
main:
;   7:   strcpy(arr, "Hello world!");
  push #arr@6
  push #@s1
  call strcpy
  add SP, #2
;   8:   putstr(arr);
  push #arr@6
  call putstr
  add SP, #1
  ret
;   9: }
  .data
arr@6: 0,0,0,0,0,0,0,0,0,0
  .ctext
  @s1: "Hello world!\0"
#### Code ####
 file   0 0000: test06.c
 code   0 0000: 1600 0059
 code   0 0002: 1C00
 code   0 0003: 1800
 file   0 0004: string.asm
 code  18 0004: 2093 0002
 code  19 0006: 20B3 0001
 code  20 0008: 2004
 code  23 0009: 2149
 code  24 000A: 5170 0009
 code  26 000C: 1800
 code  33 000D: 2093 0001
 code  34 000F: 200C
 code  37 0010: 202A
 code  38 0011: 2800
 code  39 0012: 5110 0010
 code  41 0014: 1800
 file   0 0015: stdio.asm
 code  21 0015: 2013 0001
 code  22 0017: 6580
 code  23 0018: 1800
 code  30 0019: 2093 0001
 code  31 001B: 2010 0050
 code  34 001D: 2028
 code  35 001E: 5430 0027
 code  36 0020: 2C00
 code  37 0021: 5410 0027
 code  39 0023: 6581
 code  40 0024: 2880
 code  41 0025: 1200 001D
 code  44 0027: 1800
 code  51 0028: 2013 0001
 code  52 002A: 6980
 code  55 002B: 2020
 code  56 002C: 3C30 000A
 code  57 002E: 2040
 code  58 002F: 7850 000A
 code  59 0031: 3050 0030
 code  60 0033: 6840
 code  61 0034: 2001
 code  62 0035: 5010 002B
 code  65 0037: 6C20
 code  66 0038: 5430 003D
 code  67 003A: 6581
 code  68 003B: 1200 0037
 code  71 003D: 1800
 code  78 003E: 2013 0001
 code  79 0040: 6980
 code  80 0041: 2050 0004
 code  83 0043: 2020
 code  84 0044: 3C30 0010
 code  85 0046: 7810 0010
 code  86 0048: 9410 000A
 code  87 004A: 3010 0007
 code  88 004C: 3010 0030
 code  89 004E: 6800
 code  90 004F: 2001
 code  91 0050: 7450 0043
 code  94 0052: 6C20
 code  95 0053: 5430 0058
 code  96 0055: 6581
 code  97 0056: 1200 0052
 code 100 0058: 1800
 file   2 0059: test06.c
 code   7 0059: 6A00 0067
 code   7 005B: 6A00 0071
 code   7 005D: 1600 0004
 code   7 005F: 30F0 0002
 code   8 0061: 6A00 0067
 code   8 0063: 1600 0019
 code   8 0065: 30ED
 code   8 0066: 1800
 code   4 0067: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
 code   7 0071: 4865 6C6C 6F20 776F 726C 6421 0000
#### Debug ####
 file   0 0059: "test06.c"
 file   0 0004: "string.asm"
 func   7 0004: "strcpy"
 func   8 000D: "strlen"
 endf  42 0014: "string.asm"
 file   0 0015: "stdio.asm"
 func   9 0015: "putchar"
 func  10 0019: "putstr"
 func  11 0028: "putnum"
 func  12 003E: "puthex"
 endf 101 0058: "stdio.asm"
 file   2 0059: "test06.c"
 lvar   4 0067: "arr[]"
 func   6 0059: "main"
 call   7 0004: "strcpy"
 call   8 0019: "putstr"
 svar   8    0: "@num_stack_var@"
 endf  10 0078: "test06.c"

 #### Compile 'main': test07.c ####
;##### test07.c #####
newfile test07.c
  .code
  global val1
  global ptr1
  global arr@2
  global main
  call main
  halt
@init:
;   1: var val1 = 1;
  move val1, #1
  ret
;   2: var ptr1;
;   3: static var arr[2];
;   5: static func test() {
test:
;   6:   output(0, '12');
  out #0, #12594
  ret
;   7: }
;   9: func main() {
main:
;  10:   var ptr2 = test;
  push #test
;  11:   ptr1 = test;
  move ptr1, #test
;  12:   arr[1] = test;
  move A, #arr@2
  add A, #1
  move X, A
  move [X], #test
;  14:   test();
  call test
;  15:   ptr1();
  move A, ptr1
  call A
;  16:   ptr2();
  move A, [SP+0]
  call A
;  17:   ptr1 = arr[2];
  move A, #arr@2
  add A, #2
  move X, A
  move ptr1, [X]
;  18:   ptr1();
  move A, ptr1
  call A
;  19:   output(0, '34');
  out #0, #13108
  add SP, #1
  ret
;  20: }
  .data
val1: 0
ptr1: 0
arr@2: 0,0
#### Code ####
 file   0 0000: test07.c
 code   0 0000: 1600 0009
 code   0 0002: 1C00
 code   1 0003: 222D 002A
 code   0 0005: 1800
 code   6 0006: 6590 3132
 code   6 0008: 1800
 code  10 0009: 6A00 0006
 code  11 000B: 2230 002B 0006
 code  12 000E: 2010 002C
 code  12 0010: 300D
 code  12 0011: 2080
 code  12 0012: 2110 0006
 code  14 0014: 1600 0006
 code  15 0016: 2011 002B
 code  15 0018: 1400
 code  16 0019: 2013 0000
 code  16 001B: 1400
 code  17 001C: 2010 002C
 code  17 001E: 3010 0002
 code  17 0020: 2080
 code  17 0021: 2228 002B
 code  18 0023: 2011 002B
 code  18 0025: 1400
 code  19 0026: 6590 3334
 code  19 0028: 30ED
 code  19 0029: 1800
 code   1 002A: 0000
 code   2 002B: 0000
 code   3 002C: 0000 0000
#### Debug ####
 file   0 0000: "test07.c"
 gvar   1 002A: "val1"
 gvar   2 002B: "ptr1"
 lvar   3 002C: "arr[]"
 func   5 0006: "test"
 svar   6    0: "@num_stack_var@"
 func   9 0009: "main"
 call  14 0006: "test"
 call  15 002B: "ptr1"
 call  16 0000: "ptr2"
 call  18 002B: "ptr1"
 svar  19   -1: "ptr2"
 svar  19    1: "@num_stack_var@"
 endf  21 002E: "test07.c"

 #### Compile 'main': test08.c ####
;##### test08.c #####
newfile test08.c
  .code
  global main
  call main
  halt
@init:
  ret
;##### stdio.asm #####
newfile stdio.asm
;   1: ;===================================
;   2: ; Standard I/O v1.0
;   3: ; - putchar(c)
;   4: ; - putstr(s)
;   5: ; - putnum(val)  -- decimal output
;   6: ; - puthex(val)  -- hexadecimal output
;   7: ;===================================
;   9: global putchar
  .code
  global putchar
;  10: global putstr
  global putstr
;  11: global putnum
  global putnum
;  12: global puthex
  global puthex
;  14:   .code
;  16: ;===================================
;  17: ; [01] putchar(c)
;  18: ; c: [SP+1]
;  19: ;===================================
;  20: putchar:
putchar:
;  21:   move A, [SP+1]
  move A, [SP+1]
;  22:   out  #0, A
  out  #0, A
;  23:   ret
  ret
;  25: ;===================================
;  26: ; [02] putstr(s)
;  27: ; s: [SP+1]
;  28: ;===================================
;  29: putstr:
putstr:
;  30:   move X, [SP+1]
  move X, [SP+1]
;  31:   move A, #80  ; max string size
  move A, #80  ; max string size
;  33: loop02:
loop02:
;  34:   move B, [X]
  move B, [X]
;  35:   bze  B, exit02
  bze  B, exit02
;  36:   dec  A
  dec  A
;  37:   bze  A, exit02
  bze  A, exit02
;  39:   out #0, B
  out #0, B
;  40:   inc X
  inc X
;  41:   jump loop02
  jump loop02
;  43: exit02:
exit02:
;  44:   ret
  ret
;  46: ;===================================
;  47: ; [03] putnum(val)
;  48: ; val: [SP+1]
;  49: ;===================================
;  50: putnum:
putnum:
;  51:   move A, [SP+1]
  move A, [SP+1]
;  52:   push #0        ; end-of-string
  push #0        ; end-of-string
;  54: loop03:
loop03:
;  55:   move B, A
  move B, A
;  56:   div  B, #10    ; rest in B
  div  B, #10    ; rest in B
;  57:   move C, A
  move C, A
;  58:   mod  C, #10    ; digit in C
  mod  C, #10    ; digit in C
;  59:   add  C, #48
  add  C, #48
;  60:   push C         ; store on stack
  push C         ; store on stack
;  61:   move A, B
  move A, B
;  62:   bnze A, loop03 ; next digit
  bnze A, loop03 ; next digit
;  64: output03:
output03:
;  65:   pop  B
  pop  B
;  66:   bze  B, exit03
  bze  B, exit03
;  67:   out  #0, B
  out  #0, B
;  68:   jump output03
  jump output03
;  70: exit03:
exit03:
;  71:   ret
  ret
;  73: ;===================================
;  74: ; [04] puthex(val)
;  75: ; val: [SP+1]
;  76: ;===================================
;  77: puthex:
puthex:
;  78:   move A, [SP+1]
  move A, [SP+1]
;  79:   push #0        ; end-of-string
  push #0        ; end-of-string
;  80:   move C, #4     ; num digits
  move C, #4     ; num digits
;  82: loop04:
loop04:
;  83:   move B, A
  move B, A
;  84:   div  B, #$10   ; rest in B
  div  B, #$10   ; rest in B
;  85:   mod  A, #$10   ; digit in C
  mod  A, #$10   ; digit in C
;  86:   sklt A, #10    ; C < 10 => jmp +2
  sklt A, #10    ; C < 10 => jmp +2
;  87:   add  A, #7     ; A-F offset
  add  A, #7     ; A-F offset
;  88:   add  A, #48    ; 0-9 offset
  add  A, #48    ; 0-9 offset
;  89:   push A         ; store on stack
  push A         ; store on stack
;  90:   move A, B
  move A, B
;  91:   dbnz C, loop04 ; next digit
  dbnz C, loop04 ; next digit
;  93: output04:
output04:
;  94:   pop  B
  pop  B
;  95:   bze  B, exit04
  bze  B, exit04
;  96:   out  #0, B
  out  #0, B
;  97:   jump output04
  jump output04
;  99: exit04:
exit04:
; 100:   ret
  ret
;##### test08.c #####
newfile test08.c
;   1: import "stdio.asm"
;   3: func main() {
  .code
main:
;   4:   var a = 1;
  push #1
;   5:   var b = 2;
  push #2
;   7:   if((a == 0) or (b == 2)) {
  move A, [SP+1]
  skeq A, #0
  jump +4
  jump @lbl1
  move B, [SP+0]
  skeq B, #2
  jump @lbl2
@lbl1:
;   8:     putstr("ok");
  push #@s1
  call putstr
  add SP, #1
;   9:   } else {
  jump @lbl3
@lbl2:
;  10:     putstr("error");
  push #@s2
  call putstr
  add SP, #1
@lbl3:
;  11:   }
;  13:   if((a == 1) and (b == 2)) {
  move A, [SP+1]
  skeq A, #1
  jump @lbl5
  move B, [SP+0]
  skeq B, #2
  jump @lbl5
@lbl4:
;  14:     putstr("ok");
  push #@s3
  call putstr
  add SP, #1
;  15:   } else {
  jump @lbl6
@lbl5:
;  16:     putstr("error");
  push #@s4
  call putstr
  add SP, #1
@lbl6:
;  17:   }
;  19:   if((a == 0) || (b == 2)) {
  move A, [SP+1]
  skeq A, #0
  jump +4
  jump @lbl7
  move B, [SP+0]
  skeq B, #2
  jump @lbl8
@lbl7:
;  20:     putstr("ok");
  push #@s5
  call putstr
  add SP, #1
;  21:   }
@lbl8:
;  23:   if((a == 1) && (b == 2)) {
  move A, [SP+1]
  skeq A, #1
  jump @lbl10
  move B, [SP+0]
  skeq B, #2
  jump @lbl10
@lbl9:
;  24:     putstr("ok");
  push #@s6
  call putstr
  add SP, #1
;  25:   }
@lbl10:
  add SP, #2
  ret
  .ctext
  @s1: "ok\0"
  @s2: "error\0"
  @s3: "ok\0"
  @s4: "error\0"
  @s5: "ok\0"
  @s6: "ok\0"
;  26: }
#### Code ####
 file   0 0000: test08.c
 code   0 0000: 1600 0048
 code   0 0002: 1C00
 code   0 0003: 1800
 file   0 0004: stdio.asm
 code  21 0004: 2013 0001
 code  22 0006: 6580
 code  23 0007: 1800
 code  30 0008: 2093 0001
 code  31 000A: 2010 0050
 code  34 000C: 2028
 code  35 000D: 5430 0016
 code  36 000F: 2C00
 code  37 0010: 5410 0016
 code  39 0012: 6581
 code  40 0013: 2880
 code  41 0014: 1200 000C
 code  44 0016: 1800
 code  51 0017: 2013 0001
 code  52 0019: 6980
 code  55 001A: 2020
 code  56 001B: 3C30 000A
 code  57 001D: 2040
 code  58 001E: 7850 000A
 code  59 0020: 3050 0030
 code  60 0022: 6840
 code  61 0023: 2001
 code  62 0024: 5010 001A
 code  65 0026: 6C20
 code  66 0027: 5430 002C
 code  67 0029: 6581
 code  68 002A: 1200 0026
 code  71 002C: 1800
 code  78 002D: 2013 0001
 code  79 002F: 6980
 code  80 0030: 2050 0004
 code  83 0032: 2020
 code  84 0033: 3C30 0010
 code  85 0035: 7810 0010
 code  86 0037: 9410 000A
 code  87 0039: 3010 0007
 code  88 003B: 3010 0030
 code  89 003D: 6800
 code  90 003E: 2001
 code  91 003F: 7450 0032
 code  94 0041: 6C20
 code  95 0042: 5430 0047
 code  96 0044: 6581
 code  97 0045: 1200 0041
 code 100 0047: 1800
 file   1 0048: test08.c
 code   4 0048: 69A0
 code   5 0049: 6A00 0002
 code   7 004B: 2013 0001
 code   7 004D: 900C
 code   7 004E: 1280 0004
 code   7 0050: 1200 0058
 code   7 0052: 2033 0000
 code   7 0054: 9030 0002
 code   7 0056: 1200 005F
 code   8 0058: 6A00 00A0
 code   8 005A: 1600 0008
 code   8 005C: 30ED
 code   9 005D: 1200 0064
 code  10 005F: 6A00 00A2
 code  10 0061: 1600 0008
 code  10 0063: 30ED
 code  13 0064: 2013 0001
 code  13 0066: 900D
 code  13 0067: 1200 0076
 code  13 0069: 2033 0000
 code  13 006B: 9030 0002
 code  13 006D: 1200 0076
 code  14 006F: 6A00 00A6
 code  14 0071: 1600 0008
 code  14 0073: 30ED
 code  15 0074: 1200 007B
 code  16 0076: 6A00 00A8
 code  16 0078: 1600 0008
 code  16 007A: 30ED
 code  19 007B: 2013 0001
 code  19 007D: 900C
 code  19 007E: 1280 0004
 code  19 0080: 1200 0088
 code  19 0082: 2033 0000
 code  19 0084: 9030 0002
 code  19 0086: 1200 008D
 code  20 0088: 6A00 00AC
 code  20 008A: 1600 0008
 code  20 008C: 30ED
 code  23 008D: 2013 0001
 code  23 008F: 900D
 code  23 0090: 1200 009D
 code  23 0092: 2033 0000
 code  23 0094: 9030 0002
 code  23 0096: 1200 009D
 code  24 0098: 6A00 00AE
 code  24 009A: 1600 0008
 code  24 009C: 30ED
 code  25 009D: 30F0 0002
 code  25 009F: 1800
 code   8 00A0: 6F6B 0000
 code  10 00A2: 6572 726F 0072 0000
 code  14 00A6: 6F6B 0000
 code  16 00A8: 6572 726F 0072 0000
 code  20 00AC: 6F6B 0000
 code  24 00AE: 6F6B 0000
#### Debug ####
 file   0 0048: "test08.c"
 file   0 0004: "stdio.asm"
 func   9 0004: "putchar"
 func  10 0008: "putstr"
 func  11 0017: "putnum"
 func  12 002D: "puthex"
 endf 101 0047: "stdio.asm"
 file   1 0048: "test08.c"
 func   3 0048: "main"
brnch   7 0000: "+4"
brnch   7 0058: "@lbl1"
brnch   7 005F: "@lbl2"
 call   8 0008: "putstr"
brnch   9 0064: "@lbl3"
 call  10 0008: "putstr"
brnch  13 0076: "@lbl5"
brnch  13 0076: "@lbl5"
 call  14 0008: "putstr"
brnch  15 007B: "@lbl6"
 call  16 0008: "putstr"
brnch  19 0000: "+4"
brnch  19 0088: "@lbl7"
brnch  19 008D: "@lbl8"
 call  20 0008: "putstr"
brnch  23 009D: "@lbl10"
brnch  23 009D: "@lbl10"
 call  24 0008: "putstr"
 svar  25   -1: "a"
 svar  25   -2: "b"
 svar  25    2: "@num_stack_var@"
 endf  27 00B0: "test08.c"

 #### Compile 'loop': test09.c ####
;##### test09.c #####
newfile test09.c
  .code
  global buff@3
  global send_msg
  global idx@4
  global init
  global loop
  jump 8
  .org 8
  call @init
  call init
@loop:
  call loop
  nop
  jump @loop
@init:
;   1: import "comm.c"
;   2: static var idx = 0;
  move idx@4, #0
  ret
;##### comm.c #####
newfile comm.c
;   1: const SEND_MSG = 2;
;   2: static var buff[3];
;   4: static func test(a) {
  .code
test:
;   5:   return;
  move A, #0
  ret
;   6: }
;   8: func send_msg(port, topic, size, ptr) {
send_msg:
;   9:   buff[0] = topic;
  move A, #buff@3
  add A, #0
  move X, A
  move [X], [SP+3]
;  10:   buff[1] = size;
  move A, #buff@3
  add A, #1
  move X, A
  move [X], [SP+2]
;  11:   buff[2] = ptr;
  move A, #buff@3
  add A, #2
  move X, A
  move [X], [SP+1]
;  12:   system(SEND_MSG, port, buff);
  move A, [SP+4]
  move B, #buff@3
  sys #2
;  13:   test(2);
  push #2
  call test
  add SP, #1
  ret
;##### test09.c #####
newfile test09.c
;   1: import "comm.c"
;   2: static var idx = 0;
;   5: func init() {
  .code
init:
;   6:   system(0, 'In');
  move A, #18798
  sys #0
;   7:   system(0, 'it');
  move A, #26996
  sys #0
  ret
;   8: }
;  10: func loop() {
loop:
;  11:   if(input(1) == 1) {
  in A, #1
  skeq A, #1
  jump @lbl2
@lbl1:
;  12:     output(1, idx);
  out #1, idx@4
;  13:     idx = (idx + 1) % 64;
  move A, idx@4
  add A, #1
  mod A, #64
  move idx@4, A
;  14:   } else {
  jump @lbl3
@lbl2:
;  15:     output(1, 0);
  out #1, #0
@lbl3:
;  16:   }
  ret
;  17: }
  .data
buff@3: 0,0,0
idx@4: 0
#### Code ####
 file   0 0000: test09.c
 code   0 0000: 1200 0008
 code   0 0008: 1600 0011
 code   0 000A: 1600 0034
 code   0 000C: 1600 003B
 code   0 000E: 0000
 code   0 000F: 1200 000C
 code   2 0011: 222C 004F
 code   0 0013: 1800
 file   0 0014: comm.c
 code   5 0014: 200C
 code   5 0015: 1800
 code   9 0016: 2010 004C
 code   9 0018: 300C
 code   9 0019: 2080
 code   9 001A: 2113 0003
 code  10 001C: 2010 004C
 code  10 001E: 300D
 code  10 001F: 2080
 code  10 0020: 2113 0002
 code  11 0022: 2010 004C
 code  11 0024: 3010 0002
 code  11 0026: 2080
 code  11 0027: 2113 0001
 code  12 0029: 2013 0004
 code  12 002B: 2030 004C
 code  12 002D: 0802
 code  13 002E: 6A00 0002
 code  13 0030: 1600 0014
 code  13 0032: 30ED
 code  13 0033: 1800
 file   1 0034: test09.c
 code   6 0034: 2010 496E
 code   6 0036: 0800
 code   7 0037: 2010 6974
 code   7 0039: 0800
 code   7 003A: 1800
 code  11 003B: 600D
 code  11 003C: 900D
 code  11 003D: 1200 004A
 code  12 003F: 65B1 004F
 code  13 0041: 2011 004F
 code  13 0043: 300D
 code  13 0044: 7810 0040
 code  13 0046: 2220 004F
 code  14 0048: 1200 004B
 code  15 004A: 65AC
 code  16 004B: 1800
 code   2 004C: 0000 0000 0000
 code   2 004F: 0000
#### Debug ####
 file   0 0034: "test09.c"
 file   0 0014: "comm.c"
 lvar   2 004C: "buff[]"
 func   4 0014: "test"
  ret   5 0000: "0"
 svar   5    1: "a"
 svar   5    0: "@num_stack_var@"
 func   8 0016: "send_msg"
 call  13 0014: "test"
 svar  13    4: "port"
 svar  13    3: "topic"
 svar  13    1: "ptr"
 svar  13    2: "size"
 svar  13    0: "@num_stack_var@"
 endf  15 0033: "comm.c"
 file   1 0034: "test09.c"
 lvar   2 004F: "idx"
 func   5 0034: "init"
 svar   7    0: "@num_stack_var@"
 func  10 003B: "loop"
brnch  11 004A: "@lbl2"
brnch  14 004B: "@lbl3"
 svar  16    0: "@num_stack_var@"
 endf  18 0050: "test09.c"

 #### Compile 'main': test10.c ####
;##### test10.c #####
newfile test10.c
  .code
  global test1
  global test2
  global main
  call main
  halt
@init:
  ret
;##### stdio.asm #####
newfile stdio.asm
;   1: ;===================================
;   2: ; Standard I/O v1.0
;   3: ; - putchar(c)
;   4: ; - putstr(s)
;   5: ; - putnum(val)  -- decimal output
;   6: ; - puthex(val)  -- hexadecimal output
;   7: ;===================================
;   9: global putchar
  .code
  global putchar
;  10: global putstr
  global putstr
;  11: global putnum
  global putnum
;  12: global puthex
  global puthex
;  14:   .code
;  16: ;===================================
;  17: ; [01] putchar(c)
;  18: ; c: [SP+1]
;  19: ;===================================
;  20: putchar:
putchar:
;  21:   move A, [SP+1]
  move A, [SP+1]
;  22:   out  #0, A
  out  #0, A
;  23:   ret
  ret
;  25: ;===================================
;  26: ; [02] putstr(s)
;  27: ; s: [SP+1]
;  28: ;===================================
;  29: putstr:
putstr:
;  30:   move X, [SP+1]
  move X, [SP+1]
;  31:   move A, #80  ; max string size
  move A, #80  ; max string size
;  33: loop02:
loop02:
;  34:   move B, [X]
  move B, [X]
;  35:   bze  B, exit02
  bze  B, exit02
;  36:   dec  A
  dec  A
;  37:   bze  A, exit02
  bze  A, exit02
;  39:   out #0, B
  out #0, B
;  40:   inc X
  inc X
;  41:   jump loop02
  jump loop02
;  43: exit02:
exit02:
;  44:   ret
  ret
;  46: ;===================================
;  47: ; [03] putnum(val)
;  48: ; val: [SP+1]
;  49: ;===================================
;  50: putnum:
putnum:
;  51:   move A, [SP+1]
  move A, [SP+1]
;  52:   push #0        ; end-of-string
  push #0        ; end-of-string
;  54: loop03:
loop03:
;  55:   move B, A
  move B, A
;  56:   div  B, #10    ; rest in B
  div  B, #10    ; rest in B
;  57:   move C, A
  move C, A
;  58:   mod  C, #10    ; digit in C
  mod  C, #10    ; digit in C
;  59:   add  C, #48
  add  C, #48
;  60:   push C         ; store on stack
  push C         ; store on stack
;  61:   move A, B
  move A, B
;  62:   bnze A, loop03 ; next digit
  bnze A, loop03 ; next digit
;  64: output03:
output03:
;  65:   pop  B
  pop  B
;  66:   bze  B, exit03
  bze  B, exit03
;  67:   out  #0, B
  out  #0, B
;  68:   jump output03
  jump output03
;  70: exit03:
exit03:
;  71:   ret
  ret
;  73: ;===================================
;  74: ; [04] puthex(val)
;  75: ; val: [SP+1]
;  76: ;===================================
;  77: puthex:
puthex:
;  78:   move A, [SP+1]
  move A, [SP+1]
;  79:   push #0        ; end-of-string
  push #0        ; end-of-string
;  80:   move C, #4     ; num digits
  move C, #4     ; num digits
;  82: loop04:
loop04:
;  83:   move B, A
  move B, A
;  84:   div  B, #$10   ; rest in B
  div  B, #$10   ; rest in B
;  85:   mod  A, #$10   ; digit in C
  mod  A, #$10   ; digit in C
;  86:   sklt A, #10    ; C < 10 => jmp +2
  sklt A, #10    ; C < 10 => jmp +2
;  87:   add  A, #7     ; A-F offset
  add  A, #7     ; A-F offset
;  88:   add  A, #48    ; 0-9 offset
  add  A, #48    ; 0-9 offset
;  89:   push A         ; store on stack
  push A         ; store on stack
;  90:   move A, B
  move A, B
;  91:   dbnz C, loop04 ; next digit
  dbnz C, loop04 ; next digit
;  93: output04:
output04:
;  94:   pop  B
  pop  B
;  95:   bze  B, exit04
  bze  B, exit04
;  96:   out  #0, B
  out  #0, B
;  97:   jump output04
  jump output04
;  99: exit04:
exit04:
; 100:   ret
  ret
;##### test10.c #####
newfile test10.c
;   1: import "stdio.asm"
;   3: func test1() {
  .code
test1:
;   4:   var i = 0;
  push #0
;   5:   var j = 0;
  push #0
;   7:   for(j = 0; j < 5; j++) {
  move [SP+0], #0
@lbl1:
  move A, [SP+0]
  sklt A, #5
  jump @lbl2
;   8:     for(i = 0; i < 5; i++) {
  move [SP+1], #0
@lbl4:
  move A, [SP+1]
  sklt A, #5
  jump @lbl5
;   9:       putnum(i);
  push [SP+1]
  call putnum
  add SP, #1
;  10:       if(i < 2) {
  move A, [SP+1]
  sklt A, #2
  jump @lbl8
@lbl7:
;  11:         continue;
  jump @lbl6
;  12:       }
@lbl8:
;  13:       putstr("i >= 2");
  push #@s1
  call putstr
  add SP, #1
;  14:       if(i == 4) {
  move A, [SP+1]
  skeq A, #4
  jump @lbl10
@lbl9:
;  15:         break;
  jump @lbl5
;  16:       }
@lbl10:
@lbl6:
  inc [SP+1]
  jump @lbl4
@lbl5:
;  17:     }
@lbl3:
  inc [SP+0]
  jump @lbl1
@lbl2:
;  18:   }
;  20:   i = 0;
  move [SP+1], #0
;  21:   while(1) {
@lbl11:
  move A, #1
  skgt A, #00
  jump @lbl12
;  22:     if(i>3) {
  move A, [SP+1]
  skgt A, #3
  jump @lbl14
@lbl13:
;  23:       break;
  jump @lbl12
;  24:     }
@lbl14:
;  25:     putnum(i);
  push [SP+1]
  call putnum
  add SP, #1
;  26:     i++;
  inc [SP+1]
  jump @lbl11
@lbl12:
;  27:   }
  add SP, #2
  ret
;  28: }
;  30: func test2() {
test2:
;  31:   putstr("Should not happen");
  push #@s2
  call putstr
  add SP, #1
  ret
;  32: }
;  34: func main() {
main:
;  35:   test1();
  call test1
;  37:   goto exit;
  jump exit
;  38:   test2();
  call test2
;  39:   exit:
exit:
  ret
  .ctext
  @s1: "i >= 2\0"
  @s2: "Should not happen\0"
;  40: }
#### Code ####
 file   0 0000: test10.c
 code   0 0000: 1600 009D
 code   0 0002: 1C00
 code   0 0003: 1800
 file   0 0004: stdio.asm
 code  21 0004: 2013 0001
 code  22 0006: 6580
 code  23 0007: 1800
 code  30 0008: 2093 0001
 code  31 000A: 2010 0050
 code  34 000C: 2028
 code  35 000D: 5430 0016
 code  36 000F: 2C00
 code  37 0010: 5410 0016
 code  39 0012: 6581
 code  40 0013: 2880
 code  41 0014: 1200 000C
 code  44 0016: 1800
 code  51 0017: 2013 0001
 code  52 0019: 6980
 code  55 001A: 2020
 code  56 001B: 3C30 000A
 code  57 001D: 2040
 code  58 001E: 7850 000A
 code  59 0020: 3050 0030
 code  60 0022: 6840
 code  61 0023: 2001
 code  62 0024: 5010 001A
 code  65 0026: 6C20
 code  66 0027: 5430 002C
 code  67 0029: 6581
 code  68 002A: 1200 0026
 code  71 002C: 1800
 code  78 002D: 2013 0001
 code  79 002F: 6980
 code  80 0030: 2050 0004
 code  83 0032: 2020
 code  84 0033: 3C30 0010
 code  85 0035: 7810 0010
 code  86 0037: 9410 000A
 code  87 0039: 3010 0007
 code  88 003B: 3010 0030
 code  89 003D: 6800
 code  90 003E: 2001
 code  91 003F: 7450 0032
 code  94 0041: 6C20
 code  95 0042: 5430 0047
 code  96 0044: 6581
 code  97 0045: 1200 0041
 code 100 0047: 1800
 file   1 0048: test10.c
 code   4 0048: 6980
 code   5 0049: 6980
 code   7 004A: 226C 0000
 code   7 004C: 2013 0000
 code   7 004E: 9410 0005
 code   7 0050: 1200 007C
 code   8 0052: 226C 0001
 code   8 0054: 2013 0001
 code   8 0056: 9410 0005
 code   8 0058: 1200 0078
 code   9 005A: 6A60 0001
 code   9 005C: 1600 0017
 code   9 005E: 30ED
 code  10 005F: 2013 0001
 code  10 0061: 9410 0002
 code  10 0063: 1200 0067
 code  11 0065: 1200 0074
 code  13 0067: 6A00 00A4
 code  13 0069: 1600 0008
 code  13 006B: 30ED
 code  14 006C: 2013 0001
 code  14 006E: 9010 0004
 code  14 0070: 1200 0074
 code  15 0072: 1200 0078
 code   8 0074: 2A60 0001
 code  16 0076: 1200 0054
 code   7 0078: 2A60 0000
 code  17 007A: 1200 004C
 code  20 007C: 226C 0001
 code  21 007E: 200D
 code  21 007F: 9810 0000
 code  21 0081: 1200 0094
 code  22 0083: 2013 0001
 code  22 0085: 9810 0003
 code  22 0087: 1200 008B
 code  23 0089: 1200 0094
 code  25 008B: 6A60 0001
 code  25 008D: 1600 0017
 code  25 008F: 30ED
 code  26 0090: 2A60 0001
 code  26 0092: 1200 007E
 code  27 0094: 30F0 0002
 code  27 0096: 1800
 code  31 0097: 6A00 00A8
 code  31 0099: 1600 0008
 code  31 009B: 30ED
 code  31 009C: 1800
 code  35 009D: 1600 0048
 code  37 009F: 1200 00A3
 code  38 00A1: 1600 0097
 code  39 00A3: 1800
 code  13 00A4: 6920 3E3D 2032 0000
 code  31 00A8: 5368 6F75 6C64 206E 6F74 2068 6170 7065
 code  31 00B0: 006E 0000
#### Debug ####
 file   0 0048: "test10.c"
 file   0 0004: "stdio.asm"
 func   9 0004: "putchar"
 func  10 0008: "putstr"
 func  11 0017: "putnum"
 func  12 002D: "puthex"
 endf 101 0047: "stdio.asm"
 file   1 0048: "test10.c"
 func   3 0048: "test1"
brnch   7 007C: "@lbl2"
brnch   8 0078: "@lbl5"
 call   9 0017: "putnum"
brnch  10 0067: "@lbl8"
brnch  11 0074: "@lbl6"
 call  13 0008: "putstr"
brnch  14 0074: "@lbl10"
brnch  15 0078: "@lbl5"
brnch  16 0054: "@lbl4"
brnch  17 004C: "@lbl1"
brnch  21 0094: "@lbl12"
brnch  22 008B: "@lbl14"
brnch  23 0094: "@lbl12"
 call  25 0017: "putnum"
brnch  26 007E: "@lbl11"
 svar  27   -1: "i"
 svar  27   -2: "j"
 svar  27    2: "@num_stack_var@"
 func  30 0097: "test2"
 call  31 0008: "putstr"
 svar  31    0: "@num_stack_var@"
 func  34 009D: "main"
 call  35 0048: "test1"
brnch  37 00A3: "exit"
 call  38 0097: "test2"
 svar  39   -1: "exit"
 svar  39    1: "@num_stack_var@"
 endf  42 00B2: "test10.c"

 #### Compile 'main': test11.c ####
;##### test11.c #####
newfile test11.c
  .code
  global s0
  global s1
  global s2
  global buff
  global main
  call main
  halt
@init:
;   1: var s0 = "error";
  move s0, #@s1
;   2: var s1 = "\123\145";
  move s1, #@s2
;   3: var s2 = "\001\002\003";
  move s2, #@s3
  ret
;   4: var buff[] = {0x1FF, 0777, 511};
;   6: func main() {
main:
;   7:   output(0, 0);  
  out #0, #0
  ret
;   8: }
  .data
s0: 0
s1: 0
s2: 0
buff: 511,511,511
  .ctext
  @s1: "error\0"
  @s2: "\123\145\0"
  @s3: "\001\002\003\0"
#### Code ####
 file   0 0000: test11.c
 code   0 0000: 1600 000D
 code   0 0002: 1C00
 code   1 0003: 2230 000F 0015
 code   2 0006: 2230 0010 0019
 code   3 0009: 2230 0011 001E
 code   0 000C: 1800
 code   7 000D: 658C
 code   7 000E: 1800
 code   1 000F: 0000
 code   2 0010: 0000
 code   3 0011: 0000
 code   4 0012: 01FF 01FF 01FF
 code   1 0015: 6572 726F 0072 0000
 code   2 0019: 7830 3053 7830 3065 0000
 code   3 001E: 7830 3001 7830 3002 7830 3003 0000
#### Debug ####
 file   0 0000: "test11.c"
 gvar   1 000F: "s0"
 gvar   2 0010: "s1"
 gvar   3 0011: "s2"
 gvar   4 0012: "buff[]"
 func   6 000D: "main"
 svar   7    0: "@num_stack_var@"
 endf   9 0025: "test11.c"

 #### Compile 'loop': test12.c ####
;##### test12.c #####
newfile test12.c
  .code
  global buff
  global a
  global init
  global loop
  jump 8
  .org 8
  call @init
  call init
@loop:
  call loop
  nop
  jump @loop
@init:
  ret
;   1: var buff[] = {65, 66, 67};
;   2: var a;
;   4: func init() {
init:
;   5:   var p = buff;
  push #buff
;   6:   var b;
  push #0
;   7:   var c;
  push #0
;   9:   system(0, *p);
  move X, [SP+2]
  move A, [X]
  sys #0
;  10:   system(0, p[1]);
  move A, [SP+2]
  add A, #1
  move X, A
  move A, [X]
  sys #0
;  11:   system(0, p[2]);
  move A, [SP+2]
  add A, #2
  move X, A
  move A, [X]
  sys #0
;  12:   system(0, &a);
  move A, #a
  sys #0
;  13:   system(0, &b);
  move A, SP
  add A, #1
  sys #0
  add SP, #3
  ret
;  15: }
;  17: func loop() {
loop:
;  18: }
  .data
buff: 65,66,67
a: 0
#### Code ####
 file   0 0000: test12.c
 code   0 0000: 1200 0008
 code   0 0008: 1600 0011
 code   0 000A: 1600 0012
 code   0 000C: 1600 0030
 code   0 000E: 0000
 code   0 000F: 1200 000C
 code   0 0011: 1800
 code   5 0012: 6A00 0030
 code   6 0014: 6980
 code   7 0015: 6980
 code   9 0016: 2093 0002
 code   9 0018: 2008
 code   9 0019: 0800
 code  10 001A: 2013 0002
 code  10 001C: 300D
 code  10 001D: 2080
 code  10 001E: 2008
 code  10 001F: 0800
 code  11 0020: 2013 0002
 code  11 0022: 3010 0002
 code  11 0024: 2080
 code  11 0025: 2008
 code  11 0026: 0800
 code  12 0027: 2010 0033
 code  12 0029: 0800
 code  13 002A: 2007
 code  13 002B: 300D
 code  13 002C: 0800
 code  13 002D: 30F0 0003
 code  13 002F: 1800
 code   1 0030: 0041 0042 0043
 code   2 0033: 0000
#### Debug ####
 file   0 0000: "test12.c"
 gvar   1 0030: "buff[]"
 gvar   2 0033: "a"
 func   4 0012: "init"
 svar  13   -3: "c"
 svar  13   -1: "p"
 svar  13   -2: "b"
 svar  13    3: "@num_stack_var@"
 func  17 0030: "loop"
 svar  17    0: "@num_stack_var@"
 endf  19 0034: "test12.c"

 #### Compile 'loop': test13.c ####
;##### test13.c #####
newfile test13.c
  .code
  global foo1
  global foo2
  global foo3
  global init
  global loop
  jump 8
  .org 8
  call @init
  call init
@loop:
  call loop
  nop
  jump @loop
@init:
  ret
;   1: func foo1(a) {
foo1:
;   2:   return a[2];
  move A, [SP+1]
  add A, #2
  move X, A
  move A, [X]
  ret
;   3: }
;   5: func foo2(a, b) {
foo2:
;   6:   return b[2];
  move A, [SP+1]
  add A, #2
  move X, A
  move A, [X]
  ret
;   7: }
;   9: func foo3(a, b, c) {
foo3:
;  10:   return c[2];
  move A, [SP+1]
  add A, #2
  move X, A
  move A, [X]
  ret
;  11: }
;  13: func init() {
init:
;  14:   var arr1[2];
  sub SP, #2
;  15:   var c;
  push #0
;  17:   arr1[0] = 1;
  move A, SP+1
  add A, #0
  move X, A
  move [X], #1
;  18:   c = arr1;
  move [SP+0], SP+1
;  19:   c = *arr1;
  move X, SP+1
  move [SP+0], [X]
;  20:   c = arr1[1];
  move A, SP+1
  add A, #1
  move X, A
  move [SP+0], [X]
;  21:   foo1(arr1);
  push SP+1
  call foo1
  add SP, #1
;  22:   foo2(1, arr1);
  push #1
  push SP+2
  call foo2
  add SP, #2
;  23:   foo3(1, 2, arr1);
  push #1
  push #2
  push SP+3
  call foo3
  add SP, #3
  add SP, #3
  ret
;  24: }
;  26: func loop() {
loop:
;  27: }
  .data
arr1: 0
#### Code ####
 file   0 0000: test13.c
 code   0 0000: 1200 0008
 code   0 0008: 1600 0011
 code   0 000A: 1600 0027
 code   0 000C: 1600 0054
 code   0 000E: 0000
 code   0 000F: 1200 000C
 code   0 0011: 1800
 code   2 0012: 2013 0001
 code   2 0014: 3010 0002
 code   2 0016: 2080
 code   2 0017: 2008
 code   2 0018: 1800
 code   6 0019: 2013 0001
 code   6 001B: 3010 0002
 code   6 001D: 2080
 code   6 001E: 2008
 code   6 001F: 1800
 code  10 0020: 2013 0001
 code  10 0022: 3010 0002
 code  10 0024: 2080
 code  10 0025: 2008
 code  10 0026: 1800
 code  14 0027: 34F0 0002
 code  15 0029: 6980
 code  17 002A: 2017 0001
 code  17 002C: 300C
 code  17 002D: 2080
 code  17 002E: 210D
 code  18 002F: 2277 0000 0001
 code  19 0032: 2097 0001
 code  19 0034: 2268 0000
 code  20 0036: 2017 0001
 code  20 0038: 300D
 code  20 0039: 2080
 code  20 003A: 2268 0000
 code  21 003C: 6AE0 0001
 code  21 003E: 1600 0012
 code  21 0040: 30ED
 code  22 0041: 69A0
 code  22 0042: 6AE0 0002
 code  22 0044: 1600 0019
 code  22 0046: 30F0 0002
 code  23 0048: 69A0
 code  23 0049: 6A00 0002
 code  23 004B: 6AE0 0003
 code  23 004D: 1600 0020
 code  23 004F: 30F0 0003
 code  23 0051: 30F0 0003
 code  23 0053: 1800
 code  14 0054: 0000
#### Debug ####
 file   0 0000: "test13.c"
 func   1 0012: "foo1"
  ret   2 0000: "0"
 svar   2    1: "a"
 svar   2    0: "@num_stack_var@"
 func   5 0019: "foo2"
  ret   6 0000: "0"
 svar   6    2: "a"
 svar   6    1: "b"
 svar   6    0: "@num_stack_var@"
 func   9 0020: "foo3"
  ret  10 0000: "0"
 svar  10    3: "a"
 svar  10    1: "c"
 svar  10    2: "b"
 svar  10    0: "@num_stack_var@"
 func  13 0027: "init"
 call  21 0012: "foo1"
 call  22 0019: "foo2"
 call  23 0020: "foo3"
 svar  23   -2: "c"
 svar  23   -2: "arr1"
 svar  23    2: "@num_stack_var@"
 func  26 0054: "loop"
 svar  26    0: "@num_stack_var@"
 endf  28 0055: "test13.c"

 #### Compile 'loop': test14.c ####
;##### test14.c #####
newfile test14.c
  .code
  global route
  global c
  global init
  global calc_height2
  global move_lift
  global loop
  jump 8
  .org 8
  call @init
  call init
@loop:
  call loop
  nop
  jump @loop
@init:
  ret
;   1: var route[] = {0,0,0};
;   2: var c;
;   4: func init() {
init:
;   5:   c = 1;
  move c, #1
  ret
;   6: }
;   8: func calc_height2(dest_floor) {
calc_height2:
;   9:   return dest_floor;
  move A, [SP+1]
  ret
;  10: }
;  12: func move_lift(floor) {
move_lift:
;  13:   route[1] = calc_height2(floor);
  push [SP+1]
  call calc_height2
  add SP, #1
  move B, #route
  add B, #1
  move X, B
  move [X], A
  ret
;  14: }
;  16: func loop() {
loop:
;  17:   move_lift(2);
  push #2
  call move_lift
  add SP, #1
  ret
;  18: }
  .data
route: 0,0,0
c: 0
#### Code ####
 file   0 0000: test14.c
 code   0 0000: 1200 0008
 code   0 0008: 1600 0011
 code   0 000A: 1600 0012
 code   0 000C: 1600 0022
 code   0 000E: 0000
 code   0 000F: 1200 000C
 code   0 0011: 1800
 code   5 0012: 204D
 code   5 0013: 1800
 code   9 0014: 2013 0001
 code   9 0016: 1800
 code  13 0017: 6A60 0001
 code  13 0019: 1600 0014
 code  13 001B: 30ED
 code  13 001C: 2030 0028
 code  13 001E: 302D
 code  13 001F: 2081
 code  13 0020: 2100
 code  13 0021: 1800
 code  17 0022: 6A00 0002
 code  17 0024: 1600 0017
 code  17 0026: 30ED
 code  17 0027: 1800
 code   1 0028: 0000 0000 0000
 code   2 002B: 0000
#### Debug ####
 file   0 0000: "test14.c"
 gvar   1 0028: "route[]"
 gvar   2 002B: "c"
 func   4 0012: "init"
 svar   5    0: "@num_stack_var@"
 func   8 0014: "calc_height2"
  ret   9 0000: "0"
 svar   9    1: "dest_floor"
 svar   9    0: "@num_stack_var@"
 func  12 0017: "move_lift"
 call  13 0014: "calc_height2"
 svar  13    1: "floor"
 svar  13    0: "@num_stack_var@"
 func  16 0022: "loop"
 call  17 0017: "move_lift"
 svar  17    0: "@num_stack_var@"
 endf  18 002C: "test14.c"
